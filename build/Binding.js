// Generated by CoffeeScript 1.7.1
(function() {
  var Binding, ConfigurationError, FunctionResolver, InstanceResolver, ResolutionError, SingletonLifecycle, TransientLifecycle, TypeResolver, assert, chain, sweeten, _,
    __slice = [].slice;

  assert = require('assert');

  _ = require('underscore');

  FunctionResolver = require('./resolvers/FunctionResolver');

  InstanceResolver = require('./resolvers/InstanceResolver');

  TypeResolver = require('./resolvers/TypeResolver');

  SingletonLifecycle = require('./lifecycles/SingletonLifecycle');

  TransientLifecycle = require('./lifecycles/TransientLifecycle');

  ConfigurationError = require('./errors/ConfigurationError');

  ResolutionError = require('./errors/ResolutionError');

  sweeten = function(type, property) {
    return Object.defineProperty(type.prototype, property, {
      get: function() {
        return this;
      }
    });
  };

  chain = function(func) {
    return function() {
      var args, result;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = func.apply(this, args);
      return this;
    };
  };

  Binding = (function() {
    function Binding(forge, name) {
      this.forge = forge;
      this.name = name;
      assert(this.forge != null, 'The argument "forge" must have a value');
      assert(this.name != null, 'The argument "name" must have a value');
      this.lifecycle = new SingletonLifecycle();
      this["arguments"] = {};
      this.isResolving = false;
    }

    Binding.prototype.matches = function(hint) {
      if (this.predicate != null) {
        return this.predicate(hint);
      } else {
        return true;
      }
    };

    Binding.prototype.resolve = function() {
      var result;
      if (this.lifecycle == null) {
        throw new ConfigurationError(this.name, 'No lifecycle defined');
      }
      if (this.resolver == null) {
        throw new ConfigurationError(this.name, 'No resolver defined');
      }
      if (this.isResolving) {
        throw new ResolutionError(this.name, 'Circular dependencies detected');
      }
      this.isResolving = true;
      result = this.lifecycle.getInstance(this.resolver);
      this.isResolving = false;
      return result;
    };

    sweeten(Binding, 'to');

    sweeten(Binding, 'as');

    Binding.prototype.type = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new TypeResolver(this.forge, this, target);
    });

    Binding.prototype["function"] = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new FunctionResolver(this.forge, this, target);
    });

    Binding.prototype.instance = chain(function(target) {
      assert(target != null, 'The argument "target" must have a value');
      return this.resolver = new InstanceResolver(this.forge, this, target);
    });

    Binding.prototype.singleton = chain(function() {
      return this.lifecycle = new SingletonLifecycle();
    });

    Binding.prototype.transient = chain(function() {
      return this.lifecycle = new TransientLifecycle();
    });

    Binding.prototype.when = chain(function(condition) {
      assert(condition != null, 'The argument "condition" must have a value');
      if (_.isFunction(condition)) {
        return this.predicate = condition;
      } else {
        return this.predicate = function(hint) {
          return hint === condition;
        };
      }
    });

    Binding.prototype["with"] = chain(function(args) {
      return this["arguments"] = args;
    });

    Binding.prototype.toString = function() {
      var tokens;
      tokens = [this.name];
      if (this.predicate != null) {
        tokens.push('?');
      }
      tokens.push('->');
      if (this.resolver != null) {
        tokens.push(this.resolver.toString());
      } else {
        tokens.push('?');
      }
      return tokens.join('');
    };

    return Binding;

  })();

  module.exports = Binding;

}).call(this);
